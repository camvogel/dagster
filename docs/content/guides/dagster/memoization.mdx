---
title: Versioning and Memoization | Dagster
---

# Versioning and Memoization <Experimental />

<CodeReferenceLink filePath="examples/docs_snippets/docs_snippets/guides/dagster/versioning_memoization" />

This example describes how to use Dagster's versioning and memoization features.

## Quick Start

You can enable memoization functionality by providing a (include link here) VersionStrategy to your job. Dagster provides the SourceHashVersionStrategy as a top-level export.

```python file=/guides/dagster/versioning_memoization/memoization_enabled_job.py

```

When memoization is enabled, the outputs of ops will be cached. Ops will only be re-run if:

- An upstream output's version changes
- The config to the op changes
- The version of a required resource changes
- The value returned by your VersionStrategy for that particular op changes. In the case of SourceHashVersionStrategy, this only occurs when the code within your ops and resources changes.

## How Versioning Works

The following diagram shows how an op output version is computed. (diagram here)

Notice how the version of an output depends on all upstream output versions. Because of this, output versions are computed in topological order.

This diagram describes the computation of the version of a resource. (diagram here)

Resource versions are also computed in topological order, as resources can depend on other resources.

## How Memoization Works

Memoization is enabled by using a `version_strategy`, and the use of `MemoizableIOManager`s (link here). In addition to the `handle_output` and `load_input` methods from the traditional `IOManager`, `MemoizableIOManager`s also implement a `has_output` method. This is intended to check whether an output already exists that matches specifications.

Before execution occurs, the Dagster system will determine a set of which steps actually need to run. If using memoization, Dagster will check whether all the outputs of a given step have already been memoized by calling the `has_output` method on the io manager for each output. If `has_output` returns `True` for all outputs, then the step will not run again.

All of the persistent out-of-the-box IO managers provided by Dagster are memoizable. (list them here)

## Writing a custom VersionStrategy

There will likely be cases where the default `SourceHashVersionStrategy` will not suffice. In these cases, it is advantageous to implement your own `VersionStrategy` to match your requirements.

For example, `SourceHashVersionStrategy` only takes into account the code directly within the body of an `op` or `resource`, but it's likely that you might be writing other helper functions that are subject to change. Consider the following job: (job here that has a helper function yadayadayada)

I can include the helper function in my computation like so (Version Strategy that hashes the helper function yadayadayada)

Probably include another example here talking about an op reading from an external data source, only want to rerun when that data source has changed / has new data.

## Writing a custom MemoizableIOManager

If you are using a custom IO manager and want to make use of memoization functionality, then your custom IO managers must be memoizable. This means they must implement the `has_output` function. Check out the `get_output_identifier` method on `OutputContext`, which will provide a path which includes version information that you can both store and check outputs to. Check out our implementations of io managers for inspiration.

## Disabling memoization

Sometimes, you may want to run the whole job from scratch. Memoization can be disabled by setting the `MEMOIZED_RUN_TAG` to false on your job. (Provide a code example doing this, and also in dagit).
